---
title: Scaling by Database Caching
---

### Scalability Pattern: Database Caching

#### Example, Social Graph
* Classic Relational Approach
  * Schema (like all of you have)
    * People(id, name)
    * Follow(id, follower_id, following_id)
    * Content(id, author_id)
  * Nicely normalized
    * First, Second and Third Normal form
    * Origins of the relational database
  * Queries like:
    * How many people are following user X?
    * Who is following user Y?
    * What are the most recent "n" posts (i.e. content) for user "u"?
    * What are the most recent "n" posts for users that "u" is following?
  * But to display each and every user, a join is needed!

#### Measurement
* Ask database system to analyze SQL queries that are slow
* On heroku, enable pg extras
<%= code_begin %>
heroku plugins:install heroku-pg-extras
heroku pg:psql
create extension pg_stat_statements;
\q
heroku pg:outliers
<%= code_end %>
* Discover that the social graph access was very slow
* Solution: Caching
  * Use Network scale caching (Redis) to store and share across servers

#### Putting the it together
* Example:
  * Display list of 50 most recent posts for users who are followed by user u
  * Key is: 50_tweets_for_user:uid
  * Value is: ordered list of tweet ids
* Processing:
  * When list is displayed
  * When user :u tweets
